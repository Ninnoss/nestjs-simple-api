import {
  BadRequestException,
  ConflictException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { Prisma, Role } from '@prisma/client';
import { DatabaseService } from 'src/database/database.service';
import { UpdateEmployeeDto } from './dto/update-employee-dto';

@Injectable()
export class EmployeesService {
  constructor(private readonly databaseService: DatabaseService) {}

  // it is better to use the CreateEmployeeDto class (like it is used in the controller) instead of the Prisma.EmployeeCreateInput type to validate the data. I'm leaving this here just for reference that we can also use the Prisma types generated by Prisma Client from my schema.prisma file.

  async create(createEmployeeDto: Prisma.EmployeeCreateInput) {
    const existingEmployee = await this.databaseService.employee.findUnique({
      where: { email: createEmployeeDto.email },
    });

    if (existingEmployee) {
      throw new ConflictException('Employee already exists');
    }

    return this.databaseService.employee.create({
      data: createEmployeeDto,
    });
  }

  async findAll(role?: Role) {
    // Define accepted roles
    const acceptedRoles = Object.values(Role);

    // If a role is provided, check if it's valid
    if (role) {
      if (!acceptedRoles.includes(role)) {
        throw new BadRequestException(
          `Invalid role: ${role}. Accepted roles are: ${acceptedRoles.join(', ')}`,
        );
      }

      const usersWithRole = await this.databaseService.employee.findMany({
        where: { role },
      });

      // Check if any users were found with the specified role
      if (usersWithRole.length === 0) {
        throw new NotFoundException(`No users found with role: ${role}`);
      }

      return usersWithRole;
    }

    // If no role is provided, fetch all users
    return await this.databaseService.employee.findMany();
  }

  async findOne(id: number) {
    const employee = await this.databaseService.employee.findUnique({
      where: {
        id,
      },
    });

    if (!employee) {
      throw new NotFoundException('Employee not found');
    }

    return employee;
  }

  async update(id: number, updateEmployeeDto: UpdateEmployeeDto) {
    // Check if the email already exists if it's being updated
    if (updateEmployeeDto.email) {
      const existingEmployee = await this.databaseService.employee.findUnique({
        where: { email: updateEmployeeDto.email },
      });

      if (existingEmployee) {
        throw new ConflictException('Email already exists');
      }
    }

    const employee = await this.databaseService.employee.update({
      where: {
        id,
      },
      data: updateEmployeeDto,
    });

    if (!employee) {
      throw new NotFoundException('Employee not found');
    }

    return employee;
  }

  async remove(id: number) {
    const employee = await this.databaseService.employee.findUnique({
      where: {
        id,
      },
    });

    if (!employee) {
      throw new NotFoundException('Employee not found');
    }

    await this.databaseService.employee.delete({
      where: {
        id,
      },
    });

    return 'Employee deleted Successfully';
  }
}
