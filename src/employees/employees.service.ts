import {
  ConflictException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { Prisma, Role } from '@prisma/client';
import { DatabaseService } from 'src/databse/database.service';
import { UpdateEmployeeDto } from './update-employee-dto';

@Injectable()
export class EmployeesService {
  constructor(private readonly databaseService: DatabaseService) {}

  // it is better to use the CreateEmployeeDto class (like it is used in the controller) instead of the Prisma.EmployeeCreateInput type to validate the data. I'm leaving this here just for reference that we can also use the Prisma types generated by Prisma Client from my schema.prisma file.

  async create(createEmployeeDto: Prisma.EmployeeCreateInput) {
    const existingEmployee = await this.databaseService.employee.findUnique({
      where: { email: createEmployeeDto.email },
    });

    if (existingEmployee) {
      throw new ConflictException('Employee already exists');
    }

    return this.databaseService.employee.create({
      data: createEmployeeDto,
    });
  }

  findAll(role?: Role) {
    if (role) {
      return this.databaseService.employee.findMany({
        where: {
          role,
        },
      });
    }
    return this.databaseService.employee.findMany();
  }

  async findOne(id: number) {
    const employee = await this.databaseService.employee.findUnique({
      where: {
        id,
      },
    });

    if (!employee) {
      throw new NotFoundException('Employee not found');
    }

    return employee;
  }

  async update(id: number, updateEmployeeDto: UpdateEmployeeDto) {
    // Check if the email already exists if it's being updated
    if (updateEmployeeDto.email) {
      const existingEmployee = await this.databaseService.employee.findUnique({
        where: { email: updateEmployeeDto.email },
      });

      if (existingEmployee) {
        throw new ConflictException('Email already exists');
      }
    }

    const employee = await this.databaseService.employee.update({
      where: {
        id,
      },
      data: updateEmployeeDto,
    });

    if (!employee) {
      throw new NotFoundException('Employee not found');
    }

    return employee;
  }

  async remove(id: number) {
    const employee = await this.databaseService.employee.findUnique({
      where: {
        id,
      },
    });

    if (!employee) {
      throw new NotFoundException('Employee not found');
    }

    await this.databaseService.employee.delete({
      where: {
        id,
      },
    });

    return 'Employee deleted Successfully';
  }
}
